<link rel="import" href="../tangere/tangere.html" />
<link rel="import" href="../at-core-style-classes/at-core-style-classes.html">
<link rel="import" href="../at-carbon-button/at-carbon-button.html">
<link rel="import" href="../at-core-modal/at-core-modal.html">
<link rel="import" href="../at-core-activity/at-core-activity.html">

<script src="lib/js-yaml.js"></script>

<dom-module id="at-core-modal-element">
  <template>
    <style include="at-core-style-classes">
      :host {
        display: block;
        box-sizing: border-box;
      }

      .cancel-btn {
        --at-carbon-button: {
          background-color: var(--at-light-blue);
          color: var(--at-background-text-color);
        }
      }

      .ok-btn {
        --at-carbon-button: {
          background-color: var(--at-green);
          color: var(--at-background-text-color);
        }
      }
    </style>
    <at-core-media-query id="mediaQuery" query="(min-width: 800px)" on-query-matches-changed="_handleQueryMatches"></at-core-media-query>
    <div id="messages" class="font-body1"></div>

    <at-core-modal id="coreModal" on-close-modal="_handleCloseModal" wide$="[[wide]]">
      <div id="modalContent" class$="[[elementClass]]">
        <div id="buttonContainer" class="layout-horizontal layout-center-justified" hidden>
          <at-carbon-button class="cancel-btn" label="Cancel" on-tap="_handleCancelButtonTap"></at-carbon-button>
          <at-carbon-button id="okButton" class="ok-btn" label="OK" on-tap="_handleOkButtonTap"></at-carbon-button>
        </div>
      </div>
    </at-core-modal>

    <at-core-activity id="schemaActivity" url="[[schemaUrl]]" content-type="text/plain" handle-as="text" on-response="_handleSchemaActivityResponse"
      on-error="_handleSchemaActivityError"></at-core-activity>
  </template>
</dom-module>
<script>
  Polymer({
    is: "at-core-modal-element",
    properties: {

      elementName: {
        type: String,
        value: ''
      },

      elementClass: {
        type: String,
        value: 'm'
      },

      schemaUrl: {
        type: String,
        value: ''
      },

      wide: {
        type: Boolean,
        value: false,
      },

      schema: {
        type: Object,
        value: function() {
          return {
            properties: {}
          };
        },
        observer: '_schemaChanged'
      },

      value: {
        type: Object,
        value: function() {
          return {};
        },
        observer: '_valueChanged'
      },

      _modalElementOptions: {
        type: Object,
        value: function() {
          return {};
        }
      }
    },

    observers: [
      // we do not clear error on schema changed and value changed because errors are cleared in observer functions when appropriate
      '_clearError(elementName, schemaUrl)'
    ],

    _clearError: function(elementName, schemaUrl) {
      this._setError("");
    },

    // 
    // public api
    // 
    open: function(options) {
      // one can set invalid schema or value before open is called; in that case do not open modal so that error messages are visible
      if (this._hasError()) return;

      this._modalElementOptions = options;

      // _initialize will return undefined if elementName or schemaUrl property is invalid
      if (!this._initialize()) return;

      this.$.coreModal.open();
    },

    close: function(reason) {
      this.$.coreModal.close(reason);
    },

    ready: function() { },

    // 
    // private api
    // 
    _initialize: function() {
      if (!this._isString(this.elementName)) {
        this._setError('Component name is not a string.');
        return;
      }

      if (!this.elementName.length) {
        this._setInformation('Component name is empty.');
        return;
      }

      if (!this._isString(this.schemaUrl)) {
        this._setError('schemaUrl is not a string.');
        return;
      }

      // check if element with elementName is already rendered
      var elt = this._getRenderedElement();
      if (!elt) {
        // if not import and render it
        this._importAndRender();
        return true;
      }

      // check if this.elementName property changed
      var importUrl = this._computeImportUrl(this.elementName);
      var elementName = this._computeElementName(importUrl);

      if (elt.is !== elementName) {
        // elementName changed; remove old element 
        Polymer.dom(this.$.modalContent).removeChild(elt);
        elt = null;
        // import new element and re-render
        this._importAndRender();
        return true;
      }

      // request to fetch schema from schemaUrl should not be sent before open is called
      // if schemaUrl changed between calls to .open() fetch new schema
      // if request was sent return
      if (this._fetchSchemaFromUrl(elt)) return true;

      // set value on elt
      this._setEltValue(elt);

      // set options on elt
      if (this._isObject(this._modalElementOptions)) {
        Object.keys(this._modalElementOptions).forEach(function(opt) {
          elt[opt] = this._modalElementOptions[opt];
        }, this);
      }

      // clear validation errors from UI, because validation errors should be displayed only as result of user interaction
      elt.validate(false);

      if (this._isFunction(elt.focus)) {
        elt.focus();
      }

      return true;
    },

    _importAndRender: function() {
      this._setPlaceholder();

      var importUrl = this._computeImportUrl(this.elementName);
      var self = this;

      if (!this._boundHandleImportSuccess) {
        this._boundHandleImportSuccess = this._handleImportSuccess.bind(this);
      }

      this.importHref(importUrl,
        this._boundHandleImportSuccess,
        function(event) {
          self._setError("An error occured while importing " + importUrl);
          // modal is open at this point; close it so that error message is visible
          self.$.coreModal.close();
          this._clearPlaceholder();

        }, true);
    },

    _handleImportSuccess: function(event) {
      var elementName = this._computeElementName(event.target.href);
      var elt = this.create(elementName);

      if (!elt.properties.hasOwnProperty('value')) {
        this._setError('Element ' + elementName + ' does not have value property');
        // modal is open at this point; close it so that error message is visible
        this.$.coreModal.close();
        return;
      }

      if (!this._isFunction(elt.validate)) {
        this._setError('Element ' + elementName + ' does not have validate function');
        // modal is open at this point; close it so that error message is visible
        this.$.coreModal.close();
        return;
      }

      if (this._fetchSchemaFromUrl(elt)) {
        // remove previously rendered element from DOM tree
        if (this._uiElts.renderedElt) {
          Polymer.dom(this.$.modalContent).removeChild(this._uiElts.renderedElt);
          // clear it from memory
          this._uiElts.renderedElt = null;
        }

        // keep reference of created element for latter use
        this._uiElts.renderedElt = elt;
        return;
      }

      this._renderUI(elt);
    },

    _fetchSchemaFromUrl: function(elt) {
      // if elt is an element that doesn't have schema property sending the request doesn't make sense
      var hasSchemaProp = this._isObject(elt.properties) && elt.properties.hasOwnProperty('schema');
      if (!hasSchemaProp) return false;

      var schemaUrlChanged = this._lastSchemaUrl !== this.schemaUrl;
      if (!schemaUrlChanged) return false;

      this._lastSchemaUrl = this.schemaUrl;
      if (!this.schemaUrl.length) return false;

      this.$.schemaActivity.generateRequest();
      return true;
    },

    _handleSchemaActivityError: function(error) {
      // close modal and clear placeholder, because next time _initialize is called placeholder should be set
      this.$.coreModal.close();
      this._clearPlaceholder();
    },

    _handleSchemaActivityResponse: function(response) {
      var newSchemaStr = response.detail;

      try {
        var newSchema = JSON.parse(newSchemaStr);
      } catch (e) {
        // try yaml
        try {
          newSchema = window.jsyaml.load(newSchemaStr);
        } catch (e) {
          this._setError('Data returned by remote service is not a json string nor yaml string.');
          // close modal and clear placeholder, because next time _initialize is called placeholder should be set
          this.$.coreModal.close();
          this._clearPlaceholder();
          return;
        }
      }

      if (!newSchema.hasOwnProperty('properties')) {
        this._setError('Schema must be an object that has properties property as object, or the JSON string of the former.');
        // close modal and clear placeholder, because next time _initialize is called placeholder should be set
        this.$.coreModal.close();
        this._clearPlaceholder();
        return;
      }

      // this will trigger _schemaChanged but since schemaUrl is set _schemaChanged will return immediatelly
      this.schema = newSchema;

      this._renderUI(this._uiElts.renderedElt);
    },

    _renderUI: function(elt) {
      // we need to assign elt.schema here for when elt is imported and rendered for the first time and schema is set before .open() is called
      if (this._isObject(elt.properties) && elt.properties.hasOwnProperty('schema')) {
        elt.autoValidate = true;
        var schema = this._upgradeSchema(this.schema, this.wide, this.$.mediaQuery.queryMatches);
        elt.schema = { properties: {} };
        elt.schema = schema;
      }
      // we need to assign elt.value here for when elt is imported and rendered for the first time and value is set before .open() is called
      this._setEltValue(elt);

      // set element options
      if (this._isObject(this._modalElementOptions)) {
        Object.keys(this._modalElementOptions).forEach(function(opt) {
          elt[opt] = this._modalElementOptions[opt];
        }, this);
      }

      this._clearPlaceholder();
      Polymer.dom(this.$.modalContent).insertBefore(elt, this.$.buttonContainer);

      Polymer.dom(this.$.buttonContainer).removeAttribute('hidden');
      
      // for elements that render in async manner clear UI errors when element renders
      elt.addEventListener('rendered', function() {
        elt.validate(false);
      });

      // for elements that render in sync manner clear validation errors from UI immediately
      elt.validate(false);

      if (this._isFunction(elt.focus)) {
        elt.focus();
      }
    },

    _handleCancelButtonTap: function(event) {
      this.close("cancel");
    },

    _handleOkButtonTap: function(event) {
      var elt = this._getRenderedElement();
      if (!elt) return;

      var isValid = elt.validate();
      if (!isValid) {
        event.stopPropagation();
        return;
      }

      this.close("ok");
      this.value = JSON.parse(JSON.stringify(elt.value));
      this.fire('value-changed', { value: this.value }, { bubbles: false });
    },

    _schemaChanged: function(newValue, oldValue) {
      // if schemaUrl is set ignore locally set schema
      if (this.schemaUrl) return;

      // NOTE we can validate schema object before .open is first called because presence of rendered element is not necessary

      var schemaObj = newValue;
      if (this._isString(newValue)) {
        try {
          schemaObj = JSON.parse(newValue);
        } catch (e) { }
      }

      var errorText = '';
      if (!this._isObject(schemaObj)) {
        errorText = 'Schema property must be an object, or the JSON string of the former.';

      } else if (!schemaObj.hasOwnProperty('properties')) {
        var errorText = 'Schema must be an object that has properties property as object, or the JSON string of the former.';
      }

      if (errorText.length) {
        if (this.$.coreModal.isOpen) {
          alert(errorText);

        } else {
          this._setError(errorText);
        }

        return;
      }

      this._setError("");

      schemaObj = this._upgradeSchema(schemaObj, this.wide, this.$.mediaQuery.queryMatches);
      var schemaChangedFn = this._schemaChanged;
      this._schemaChanged = function() { };
      this.schema = schemaObj;
      this._schemaChanged = schemaChangedFn;

      var elt = this._getRenderedElement();
      if (!elt) return;

      elt.schema = schemaObj;
    },

    _valueChanged: function(newValue, oldValue) {
      // NOTE we can not validate value before .open is first called because presence of rendered element is necessary
      // we need to know the type of renderedElement.value property to do the validation correctly

      var elt = this._getRenderedElement();
      if (!elt) return;

      this._setError("");

      if (newValue === null || newValue === undefined) {
        elt.value = newValue;
        return;
      }

      var errorText = "";

      var expValue = this._getInitialValue(elt);
      var actValue = newValue;
      if (typeof expValue == "object" && this._isString(newValue)) {
        try {
          // parse JSON strings of arrays or objects
          actValue = JSON.parse(newValue);
        } catch (e) {
          errorText = 'Invalid value json string: ' + e;
        }
      }

      var actValueType = this._getTypeString(actValue);
      var expValueType = this._getTypeString(expValue);
      if (actValueType !== expValueType) {
        errorText = 'Value type mismatch. Type of ' + expValueType + ' was expected but ' + actValueType + ' was given instead.';
      }

      if (errorText.length) {
        if (this.$.coreModal.isOpen) {
          alert(errorText)

        } else {
          this._setError(errorText);
        }

        return;
      }

      this._setError("");

      this._setEltValue(elt);
    },

    _handleCloseModal: function(event) {
      this.fire('close-modal', event.detail);
    },

    _handleQueryMatches: function(event) {
      var elt = this._getRenderedElement();
      if (!elt) return;

      var value = event.detail.value;
      if (!elt.properties.hasOwnProperty('schema')) return;

      var schema = this._upgradeSchema(elt.schema, this.wide, this.$.mediaQuery.queryMatches);

      elt.schema = { properties: {} };
      elt.schema = schema;
      elt.validate(false);
    },

    // 
    // helper functions and properties
    //
    _placeholderText: '<div class="placeholder-text"></div><div class="placeholder-text mtsm"></div>',

    get _uiElts() {
      if (!this._ui__elts_) {
        this._ui__elts_ = {
          placeholderElt: null,
          renderedElt: null
        };
      }
      return this._ui__elts_;
    },

    _setPlaceholder: function() {
      var placeholderElt = this._uiElts.placeholderElt;
      if (!placeholderElt) {
        var placeholderElt = this.create('div');
        Polymer.dom(placeholderElt).innerHTML = this._placeholderText;
        this._uiElts.placeholderElt = placeholderElt;
      }

      Polymer.dom(this.$.modalContent).insertBefore(placeholderElt.childNodes[0], this.$.buttonContainer);
      Polymer.dom(this.$.modalContent).insertBefore(placeholderElt.childNodes[0], this.$.buttonContainer);
    },

    _clearPlaceholder: function() {
      var refNode = this.$.buttonContainer;
      var prevSib = Polymer.dom(refNode).previousSibling;
      while (prevSib !== null) {
        var tmp = prevSib;
        prevSib = Polymer.dom(prevSib).previousSibling;

        if (this._uiElts.placeholderElt.childNodes.length === 0) {
          this._uiElts.placeholderElt.appendChild(tmp);

        } else {
          var tmpRefNode = this._uiElts.placeholderElt.childNodes[0];
          this._uiElts.placeholderElt.insertBefore(tmp, tmpRefNode);
        }
      }
    },

    _computeImportUrl: function(elementName) {
      // compute importHref
      var importUrl = elementName;
      var fsIndex = importUrl.indexOf("/");
      if (fsIndex > 0) {
        importUrl = importUrl.substring(fsIndex + 1);
      }

      // expand relative name with name prefix
      if (importUrl.indexOf(".card") > 0) {
        var resolve = { namePrefix: "" };
        this.fire("resolve-name-prefix", resolve);
        var prefix = resolve.namePrefix;

        if (importUrl == "default.view") importUrl = "";
        importUrl = importUrl.replace("default.", "");
        importUrl = prefix + "/" + prefix + (importUrl ? ("-" + importUrl.replace(".", "-")) : "");
      }

      // load item-component from other component (itemComponent = component-name/item-component) or from localfolder (item-component)
      var compUrl = this.resolveUrl("../");
      if (document.URL.indexOf("/elements/designer-element/") >= 0) compUrl = "/components/"; // standalone designer preview?

      if (window.ComponentsBase != undefined) compUrl = window.ComponentsBase;

      importUrl = fsIndex >= 0 ? compUrl + elementName + ".html" : importUrl + ".html";
      return importUrl;
    },

    _computeElementName: function(importUrl) {
      var elementName = importUrl.substring(importUrl.lastIndexOf("/") + 1);
      elementName = elementName.replace(".html", "");
      return elementName;
    },

    _getRenderedElement: function() {
      var elt = Polymer.dom(this.$.modalContent).firstElementChild;
      if (elt.classList.contains("placeholder-text")) return null;
      if (elt.id === "buttonContainer") return null;
      return elt;
    },

    _hasError: function() {
      return this.$.messages.textContent.length > 0;
    },

    _setError: function(text) {
      Polymer.dom(this.$.messages).innerHTML = '';
      Polymer.dom(this.$.messages).classList.remove('info');
      Polymer.dom(this.$.messages).classList.add('error');
      Polymer.dom(this.$.messages).textContent = text;
      Polymer.dom(this.$.messages).removeAttribute('hidden');
    },

    _setInformation: function(text) {
      Polymer.dom(this.$.messages).innerHTML = '';
      Polymer.dom(this.$.messages).classList.remove('error');
      Polymer.dom(this.$.messages).classList.add('info');
      Polymer.dom(this.$.messages).textContent = text;
      Polymer.dom(this.$.messages).removeAttribute('hidden');
    },

    _setEltValue: function(elt) {
      var expValue = this._getInitialValue(elt);
      if (typeof expValue == "object") {
        elt.value = JSON.parse(JSON.stringify(this.value));
        return;
      }

      if (typeof this.value == "object") this.value = "";

      elt.value = this.value;
    },

    _getInitialValue: function(elt) {
      var value = elt.properties.value.value;
      if (this._isFunction(value)) {
        value = value();
      }
      return value;
    },

    /* upgrades schema with xgridcols if necessary */
    _upgradeSchema: function(schema, wide, queryMatches) {
      var propNames = Object.keys(schema.properties);

      propNames.forEach(function(propName) {
        var propDef = schema.properties[propName];

        if (!propDef.hasOwnProperty('_isUserSetxGridCols')) {
          propDef._isUserSetxGridCols = propDef.hasOwnProperty('xgridcols');
        }
        if (propDef._isUserSetxGridCols) return;

        if (wide && queryMatches) {
          propDef.xgridcols = "6";

        } else {
          propDef.xgridcols = "12";
        }
      }, this);

      return schema;
    },

    _isString: function(obj) { return Object.prototype.toString.call(obj) === "[object String]"; },
    _isFunction: function(obj) { return Object.prototype.toString.call(obj) === "[object Function]"; },
    _isObject: function(obj) { return Object.prototype.toString.call(obj) === "[object Object]"; },
    _getTypeString: function(obj) { return Object.prototype.toString.call(obj); }
  });
</script>
